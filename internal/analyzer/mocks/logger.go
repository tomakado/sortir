// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"go.tomakado.io/sortir/internal/analyzer"
	"sync"
)

// Ensure, that LoggerMock does implement analyzer.Logger.
// If this is not the case, regenerate this file with moq.
var _ analyzer.Logger = &LoggerMock{}

// LoggerMock is a mock implementation of analyzer.Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked analyzer.Logger
//		mockedLogger := &LoggerMock{
//			VerboseFunc: func(s string, vs ...any)  {
//				panic("mock out the Verbose method")
//			},
//		}
//
//		// use mockedLogger in code that requires analyzer.Logger
//		// and then make assertions.
//
//	}
type LoggerMock struct {
	// VerboseFunc mocks the Verbose method.
	VerboseFunc func(s string, vs ...any)

	// calls tracks calls to the methods.
	calls struct {
		// Verbose holds details about calls to the Verbose method.
		Verbose []struct {
			// S is the s argument value.
			S string
			// Vs is the vs argument value.
			Vs []any
		}
	}
	lockVerbose sync.RWMutex
}

// Verbose calls VerboseFunc.
func (mock *LoggerMock) Verbose(s string, vs ...any) {
	if mock.VerboseFunc == nil {
		panic("LoggerMock.VerboseFunc: method is nil but Logger.Verbose was just called")
	}
	callInfo := struct {
		S  string
		Vs []any
	}{
		S:  s,
		Vs: vs,
	}
	mock.lockVerbose.Lock()
	mock.calls.Verbose = append(mock.calls.Verbose, callInfo)
	mock.lockVerbose.Unlock()
	mock.VerboseFunc(s, vs...)
}

// VerboseCalls gets all the calls that were made to Verbose.
// Check the length with:
//
//	len(mockedLogger.VerboseCalls())
func (mock *LoggerMock) VerboseCalls() []struct {
	S  string
	Vs []any
} {
	var calls []struct {
		S  string
		Vs []any
	}
	mock.lockVerbose.RLock()
	calls = mock.calls.Verbose
	mock.lockVerbose.RUnlock()
	return calls
}
